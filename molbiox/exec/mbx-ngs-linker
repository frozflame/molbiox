#!/usr/bin/env python3
# coding: utf-8

from __future__ import unicode_literals, print_function

import argparse

import sys
import pysam

from molbiox.algor import mapping
from molbiox.iofmt import fasta

ext = '.ctg-link'

def make_length_dict(samfile):
    lendict = dict()
    for d in samfile.header['SQ']:
        sn = d['SN']
        ln = d['LN']
        lendict[sn] = ln
    return lendict



def report1(samfile, contig, args):
    global lendict

    # core procedure
    counter = mapping.find_next_contigs(
        samfile, contig, lendict, args.insertmax, args.direction)

    if not counter:
        return None

    # contigs deduplicated
    nextcontigs = {k[0] for k in counter}
    nextcontigs = list(nextcontigs)

    keyfunc = lambda c: counter.get((c, 'same'), 0) + counter.get((c, 'diff'), 0)
    nextcontigs.sort(key=keyfunc, reverse=True)

    # max width for contig names, better formatting
    width = max(len(c) for c in nextcontigs)
    width = max(width, len(contig))

    # instead of from..to.., use from..prev/next..
    to = args.direction.upper()

    if args.verbose:
        print('\n#', 'STRAND', 'FROM'.ljust(width), to.ljust(width), sep='\t')
    else:
        print('\n#', 'STRAND', 'FROM', to.ljust(width), sep='\t')

    for nextcontig in nextcontigs:
        thiscontig_ = contig.ljust(width) if args.verbose else '.'.ljust(4)
        nextcontig_ = nextcontig.ljust(width)

        v1 = counter.get((nextcontig, 'same'), 0)
        v2 = counter.get((nextcontig, 'diff'), 0)

        if v1 + v2 < args.threshold:
            break

        if v1 > 0:
            print(v1, 'diff', thiscontig_, nextcontig_, sep='\t')
        if v2 > 0:
            print(v2, 'same', thiscontig_, nextcontig_, sep='\t')


def report2(samfile, contig, args):
    if args.direction == 'both':
        direction = args.direction

        args.direction = 'prev'
        report1(samfile, contig, args)

        args.direction = 'next'
        report1(samfile, contig, args)

        args.direction = direction

    else:
        report1(samfile, contig, args)


if __name__ == '__main__':

    desc = 'Link contigs using read-pair info'
    parser = argparse.ArgumentParser(description=desc)

    parser.add_argument(
        '-m', '--insertmax', type=int, default=400,
        help='max insert size between 2 paired reads')

    parser.add_argument(
        '-c', '--contig', default='ALL',
        help='contig identifier (partial contig name is OK)')

    # overrided by contig == ALL
    parser.add_argument(
        '-d', '--direction', default='both',
        choices=['prev', 'next', 'both'],
        help='direction')

    parser.add_argument(
        '-t', '--threshold', type=int, default=0,
        help='minimum number of read pairs'
    )

    parser.add_argument(
        '-r', '--orientation', type=int, default=0,
        help=''
    )

    # overrided by contig == ALL
    parser.add_argument(
        '-v', '--verbose', action='store_true',
        help='include starting contig'
    )

    parser.add_argument(
        'filename', metavar='BAM-file', help='an input BAM file')

    args = parser.parse_args()

    samfile = pysam.AlignmentFile(args.filename, "rb")

    # list of reference contigs
    refs = samfile.references
    lendict = make_length_dict(samfile)

    if args.contig.lower() == 'all':
        args.verbose = True
        print('#', 'ALL CONTIGS', sep='\t', end='\n#\n')
        for contig in refs:
            # main procedure
            report2(samfile, contig, args)

    else:
        contig = fasta.match_contig_name(refs, args.contig)
        if contig:
            print('#', contig, sep='\t', end='\n#\n')

            if args.direction == 'both':
                # main procedure
                report2(samfile, contig, args)

        else:
            print('error: contig not found', file=sys.stderr)
